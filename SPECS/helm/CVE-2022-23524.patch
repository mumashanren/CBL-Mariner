From 3caf8b586b47e838e492f9ec05396bf8c5851b92 Mon Sep 17 00:00:00 2001
From: Martin Hickey <martin.hickey@ie.ibm.com>
Date: Fri, 25 Nov 2022 18:16:43 +0000
Subject: [PATCH] Update string handling

Signed-off-by: Martin Hickey <martin.hickey@ie.ibm.com>
(cherry picked from commit a59e58468430bf9b454426ff22f5f367185b7d77)
---
 pkg/strvals/parser.go      | 28 ++++++++++++------
 pkg/strvals/parser_test.go | 58 ++++++++++++++++++++++++++++++++++++--
 2 files changed, 76 insertions(+), 10 deletions(-)

diff -urpN a/pkg/strvals/parser.go helm-3.4.1/pkg/strvals/parser.go
--- a/pkg/strvals/parser.go	2020-11-11 14:44:01.000000000 -0500
+++ helm-3.4.1/pkg/strvals/parser.go	2023-02-10 10:43:36.839848912 -0500
@@ -29,6 +29,10 @@ import (
 // ErrNotList indicates that a non-list was treated as a list.
 var ErrNotList = errors.New("not a list")
 
+// MaxNestedNameLevel is the maximum level of nesting for a value name that
+// will be allowed.
+var MaxNestedNameLevel = 30
+
 // ToYAML takes a string of arguments and converts to a YAML document.
 func ToYAML(s string) (string, error) {
 	m, err := Parse(s)
@@ -131,7 +135,7 @@ func newFileParser(sc *bytes.Buffer, dat
 
 func (t *parser) parse() error {
 	for {
-		err := t.key(t.data)
+		err := t.key(t.data, 0)
 		if err == nil {
 			continue
 		}
@@ -150,7 +154,7 @@ func runeSet(r []rune) map[rune]bool {
 	return s
 }
 
-func (t *parser) key(data map[string]interface{}) (reterr error) {
+func (t *parser) key(data map[string]interface{}, nestedNameLevel int) (reterr error) {
 	defer func() {
 		if r := recover(); r != nil {
 			reterr = fmt.Errorf("unable to parse key: %s", r)
@@ -180,7 +184,7 @@ func (t *parser) key(data map[string]int
 			}
 
 			// Now we need to get the value after the ].
-			list, err = t.listItem(list, i)
+			list, err = t.listItem(list, i, nestedNameLevel)
 			set(data, kk, list)
 			return err
 		case last == '=':
@@ -211,6 +215,12 @@ func (t *parser) key(data map[string]int
 			set(data, string(k), "")
 			return errors.Errorf("key %q has no value (cannot end with ,)", string(k))
 		case last == '.':
+			// Check value name is within the maximum nested name level
+			nestedNameLevel++
+			if nestedNameLevel > MaxNestedNameLevel {
+				return fmt.Errorf("value name nested level is greater than maximum supported nested level of %d", MaxNestedNameLevel)
+			}
+
 			// First, create or find the target map.
 			inner := map[string]interface{}{}
 			if _, ok := data[string(k)]; ok {
@@ -218,12 +228,14 @@ func (t *parser) key(data map[string]int
 			}
 
 			// Recurse
-			e := t.key(inner)
+			if e := t.key(inner, nestedNameLevel); e != nil {
+				return e
+			}
 			if len(inner) == 0 {
 				return errors.Errorf("key map %q has no value", string(k))
 			}
 			set(data, string(k), inner)
-			return e
+			return nil
 		}
 	}
 }
@@ -269,7 +281,7 @@ func (t *parser) keyIndex() (int, error)
 	return strconv.Atoi(string(v))
 
 }
-func (t *parser) listItem(list []interface{}, i int) ([]interface{}, error) {
+func (t *parser) listItem(list []interface{}, i, nestedNameLevel int) ([]interface{}, error) {
 	if i < 0 {
 		return list, fmt.Errorf("negative %d index not allowed", i)
 	}
@@ -314,7 +326,7 @@ func (t *parser) listItem(list []interfa
 			}
 		}
 		// Now we need to get the value after the ].
-		list2, err := t.listItem(crtList, nextI)
+		list2, err := t.listItem(crtList, nextI, nestedNameLevel)
 		if err != nil {
 			return list, err
 		}
@@ -333,7 +345,7 @@ func (t *parser) listItem(list []interfa
 		}
 
 		// Recurse
-		e := t.key(inner)
+		e := t.key(inner, nestedNameLevel)
 		if e != nil {
 			return list, e
 		}
diff -urpN a/pkg/strvals/parser_test.go helm-3.4.1/pkg/strvals/parser_test.go
--- a/pkg/strvals/parser_test.go	2020-11-11 14:44:01.000000000 -0500
+++ helm-3.4.1/pkg/strvals/parser_test.go	2023-02-10 10:43:36.839848912 -0500
@@ -16,6 +16,7 @@ limitations under the License.
 package strvals
 
 import (
+	"fmt"
 	"testing"
 
 	"sigs.k8s.io/yaml"
@@ -239,8 +240,9 @@ func TestParseSet(t *testing.T) {
 			err: true,
 		},
 		{
-			str:    "name1.name2=",
-			expect: map[string]interface{}{"name1": map[string]interface{}{"name2": ""}},
+			"name1.name2=",
+			map[string]interface{}{},
+			false,
 		},
 		{
 			str: "name1.=name2",
@@ -645,3 +647,55 @@ func TestToYAML(t *testing.T) {
 		t.Errorf("Expected %q, got %q", expect, o)
 	}
 }
+
+func TestParseSetNestedLevels(t *testing.T) {
+	var keyMultipleNestedLevels string
+	for i := 1; i <= MaxNestedNameLevel+2; i++ {
+		tmpStr := fmt.Sprintf("name%d", i)
+		if i <= MaxNestedNameLevel+1 {
+			tmpStr = tmpStr + "."
+		}
+		keyMultipleNestedLevels += tmpStr
+	}
+	tests := []struct {
+		str    string
+		expect map[string]interface{}
+		err    bool
+	}{
+		{
+			"outer.middle.inner=value",
+			map[string]interface{}{"outer": map[string]interface{}{"middle": map[string]interface{}{"inner": "value"}}},
+			false,
+		},
+		{
+			str: keyMultipleNestedLevels + "=value",
+			err: true,
+		},
+	}
+
+	for _, tt := range tests {
+		got, err := Parse(tt.str)
+		if err != nil {
+			if tt.err {
+				continue
+			}
+			t.Fatalf("%s: %s", tt.str, err)
+		}
+		if tt.err {
+			t.Errorf("%s: Expected error. Got nil", tt.str)
+		}
+
+		y1, err := yaml.Marshal(tt.expect)
+		if err != nil {
+			t.Fatal(err)
+		}
+		y2, err := yaml.Marshal(got)
+		if err != nil {
+			t.Fatalf("Error serializing parsed value: %s", err)
+		}
+
+		if string(y1) != string(y2) {
+			t.Errorf("%s: Expected:\n%s\nGot:\n%s", tt.str, y1, y2)
+		}
+	}
+}

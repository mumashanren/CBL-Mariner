diff -ruN a/hw/intc/arm_gicv3_redist.c b/hw/intc/arm_gicv3_redist.c
--- a/hw/intc/arm_gicv3_redist.c	2019-12-12 10:20:47.000000000 -0800
+++ b/hw/intc/arm_gicv3_redist.c	2022-06-27 15:58:13.914229178 -0700
@@ -450,7 +450,7 @@
         break;
     }
 
-    if (r == MEMTX_ERROR) {
+    if (r != MEMTX_OK) {
         qemu_log_mask(LOG_GUEST_ERROR,
                       "%s: invalid guest read at offset " TARGET_FMT_plx
                       "size %u\n", __func__, offset, size);
@@ -507,7 +507,7 @@
         break;
     }
 
-    if (r == MEMTX_ERROR) {
+    if (r != MEMTX_OK) {
         qemu_log_mask(LOG_GUEST_ERROR,
                       "%s: invalid guest write at offset " TARGET_FMT_plx
                       "size %u\n", __func__, offset, size);
--
1.8.3.1

diff -ruN a/include/exec/memattrs.h b/include/exec/memattrs.h
--- a/include/exec/memattrs.h	2019-12-12 10:20:47.000000000 -0800
+++ b/include/exec/memattrs.h	2022-06-27 16:16:55.164152752 -0700
@@ -35,6 +35,14 @@
     unsigned int secure:1;
     /* Memory access is usermode (unprivileged) */
     unsigned int user:1;
+    /*
+     * Bus interconnect and peripherals can access anything (memories,
+     * devices) by default. By setting the 'memory' bit, bus transaction
+     * are restricted to "normal" memories (per the AMBA documentation)
+     * versus devices. Access to devices will be logged and rejected
+     * (see MEMTX_ACCESS_ERROR).
+     */
+    unsigned int memory:1;
     /* Requester ID (for MSI for example) */
     unsigned int requester_id:16;
     /* Invert endianness for this page */
@@ -66,6 +74,7 @@
 #define MEMTX_OK 0
 #define MEMTX_ERROR             (1U << 0) /* device returned an error */
 #define MEMTX_DECODE_ERROR      (1U << 1) /* nothing at that address */
+#define MEMTX_ACCESS_ERROR      (1U << 2) /* access denied */
 typedef uint32_t MemTxResult;
 
 #endif

 --
 2.33.1
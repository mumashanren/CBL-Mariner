From 137719522a8ea5b380fbb6206d2466f402f5b554 Mon Sep 17 00:00:00 2001
From: "W.C.A. Wijngaards" <wouter@nlnetlabs.nl>
Date: Wed, 21 Sep 2022 11:10:38 +0200
Subject: [PATCH] - Patch for CVE-2022-3204 Non-Responsive Delegation Attack.

---
 doc/Changelog           |  3 +++
 iterator/iter_delegpt.c |  3 +++
 iterator/iter_delegpt.h |  2 ++
 iterator/iter_utils.c   |  3 +++
 iterator/iter_utils.h   |  9 +++++++++
 iterator/iterator.c     | 36 +++++++++++++++++++++++++++++++++++-
 services/cache/dns.c    |  3 +++
 services/mesh.c         |  7 +++++++
 services/mesh.h         | 11 +++++++++++
 9 files changed, 76 insertions(+), 1 deletion(-)

diff -ruN a/doc/Changelog b/doc/Changelog
--- a/doc/Changelog	2020-02-20 04:24:14.000000000 -0800
+++ b/doc/Changelog	2022-12-09 14:23:26.464982764 -0800
@@ -1,3 +1,6 @@
+21 September 2022: Wouter
+	- Patch for CVE-2022-3204 Non-Responsive Delegation Attack.
+
 20 February 2020: Wouter
 	- Updated contrib/unbound_smf23.tar.gz with Solaris SMF service for
 	  Unbound from Yuri Voinov.
	  diff -ruN a/iterator/iterator.c b/iterator/iterator.c
--- a/iterator/iterator.c	2020-02-20 04:24:14.000000000 -0800
+++ b/iterator/iterator.c	2022-12-09 16:54:13.123931036 -0800
@@ -1120,6 +1120,15 @@
 		(qstate->query_flags&BIT_RD) && !(qstate->query_flags&BIT_CD)){
 		return;
 	}
+	/* we do not generate this prefetch when the query list is full,
+	 * the query is fetched, if needed, when the validator wants it.
+	 * At that time the validator waits for it, after spawning it.
+	 * This means there is one state that uses cpu and a socket, the
+	 * spawned while this one waits, and not several at the same time,
+	 * if we had created the lookup here. And this helps to keep
+	 * the total load down, but the query still succeeds to resolve. */
+	if(mesh_jostle_exceeded(qstate->env->mesh))
+		return;
 
 	/* if the DNSKEY is in the cache this lookup will stop quickly */
 	log_nametypeclass(VERB_ALGO, "schedule dnskey prefetch", 
@@ -1825,6 +1834,14 @@
 				return 0;
 			}
 			query_count++;
+			/* If the mesh query list is full, exit the loop here.
+			 * This makes the routine spawn one query at a time,
+			 * and this means there is no query state load
+			 * increase, because the spawned state uses cpu and a
+			 * socket while this state waits for that spawned
+			 * state. Next time we can look up further targets */
+			if(mesh_jostle_exceeded(qstate->env->mesh))
+				break;
 		}
 		/* Send the A request. */
 		if(ie->supports_ipv4 && !ns->got4) {
@@ -1837,6 +1854,9 @@
 				return 0;
 			}
 			query_count++;
+			/* If the mesh query list is full, exit the loop. */
+			if(mesh_jostle_exceeded(qstate->env->mesh))
+				break;
 		}
 
 		/* mark this target as in progress. */
@@ -1993,6 +2013,15 @@
 			}
 			ns->done_pside6 = 1;
 			query_count++;
+			if(mesh_jostle_exceeded(qstate->env->mesh)) {
+				/* Wait for the lookup; do not spawn multiple
+				 * lookups at a time. */
+				verbose(VERB_ALGO, "try parent-side glue lookup");
+				iq->num_target_queries += query_count;
+				target_count_increase(iq, query_count);
+				qstate->ext_state[id] = module_wait_subquery;
+				return 0;
+			}
 		}
 		if(ie->supports_ipv4 && !ns->done_pside4) {
 			/* Send the A request. */
@@ -2324,7 +2353,6 @@
-		&& iq->sent_count < TARGET_FETCH_STOP) {
+		&& iq->sent_count < TARGET_FETCH_STOP && !mesh_jostle_exceeded(qstate->env->mesh)) {
 		tf_policy = ie->target_fetch_policy[iq->depth];
 	}
-
 	/* if in 0x20 fallback get as many targets as possible */
 	if(iq->caps_fallback) {
 		int extra = 0;
diff -ruN a/iterator/iter_delegpt.c b/iterator/iter_delegpt.c
--- a/iterator/iter_delegpt.c	2020-02-20 04:24:14.000000000 -0800
+++ b/iterator/iter_delegpt.c	2022-12-09 14:25:28.122483810 -0800
@@ -76,6 +76,7 @@
 	for(ns = dp->nslist; ns; ns = ns->next) {
 		if(!delegpt_add_ns(copy, region, ns->name, ns->lame))
 			return NULL;
+		copy->nslist->cache_lookup_count = ns->cache_lookup_count;
 		copy->nslist->resolved = ns->resolved;
 		copy->nslist->got4 = ns->got4;
 		copy->nslist->got6 = ns->got6;
@@ -119,6 +120,7 @@
 	ns->namelen = len;
 	dp->nslist = ns;
 	ns->name = regional_alloc_init(region, name, ns->namelen);
+	ns->cache_lookup_count = 0;
 	ns->resolved = 0;
 	ns->got4 = 0;
 	ns->got6 = 0;
@@ -588,6 +590,7 @@
 	}
 	ns->next = dp->nslist;
 	dp->nslist = ns;
+	ns->cache_lookup_count = 0;
 	ns->resolved = 0;
 	ns->got4 = 0;
 	ns->got6 = 0;
diff --git a/iterator/iter_delegpt.h b/iterator/iter_delegpt.h
index 62c8edc51..586597a69 100644
--- a/iterator/iter_delegpt.h
+++ b/iterator/iter_delegpt.h
@@ -101,6 +101,8 @@ struct delegpt_ns {
 	uint8_t* name;
 	/** length of name */
 	size_t namelen;
+	/** number of cache lookups for the name */
+	int cache_lookup_count;
 	/** 
 	 * If the name has been resolved. false if not queried for yet.
 	 * true if the A, AAAA queries have been generated.
iff -ruN a/iterator/iter_utils.c b/iterator/iter_utils.c
--- a/iterator/iter_utils.c	2020-02-20 04:24:14.000000000 -0800
+++ b/iterator/iter_utils.c	2022-12-09 14:26:15.235113071 -0800
@@ -1134,6 +1134,9 @@
 	struct delegpt_ns* ns;
 	size_t num = delegpt_count_targets(dp);
 	for(ns = dp->nslist; ns; ns = ns->next) {
+		if(ns->cache_lookup_count > ITERATOR_NAME_CACHELOOKUP_MAX_PSIDE)
+			continue;
+		ns->cache_lookup_count++;
 		/* get cached parentside A */
 		akey = rrset_cache_lookup(env->rrset_cache, ns->name, 
 			ns->namelen, LDNS_RR_TYPE_A, qinfo->qclass, 
diff -ruN a/iterator/iter_utils.h b/iterator/iter_utils.h
--- a/iterator/iter_utils.h	2020-02-20 04:24:14.000000000 -0800
+++ b/iterator/iter_utils.h	2022-12-09 14:27:09.804053314 -0800
@@ -60,6 +60,15 @@
 struct sock_list;
 struct ub_packed_rrset_key;
 
+/* max number of lookups in the cache for target nameserver names.
+ * This stops, for large delegations, N*N lookups in the cache. */
+#define ITERATOR_NAME_CACHELOOKUP_MAX	3
+/* max number of lookups in the cache for parentside glue for nameserver names
+ * This stops, for larger delegations, N*N lookups in the cache.
+ * It is a little larger than the nonpside max, so it allows a couple extra
+ * lookups of parent side glue. */
+#define ITERATOR_NAME_CACHELOOKUP_MAX_PSIDE	5
+
 /**
  * Process config options and set iterator module state.
  * Sets default values if no config is found.
diff --git a/services/cache/dns.c b/services/cache/dns.c
index 6bca8d85f..b6e569734 100644
--- a/services/cache/dns.c
+++ b/services/cache/dns.c
@@ -404,6 +404,9 @@ cache_fill_missing(struct module_env* env, uint16_t qclass,
 	struct ub_packed_rrset_key* akey;
 	time_t now = *env->now;
 	for(ns = dp->nslist; ns; ns = ns->next) {
+		if(ns->cache_lookup_count > ITERATOR_NAME_CACHELOOKUP_MAX)
+			continue;
+		ns->cache_lookup_count++;
 		akey = rrset_cache_lookup(env->rrset_cache, ns->name, 
 			ns->namelen, LDNS_RR_TYPE_A, qclass, 0, now, 0);
 		if(akey) {
diff -ruN a/services/mesh.c b/services/mesh.c
--- a/services/mesh.c	2020-02-20 04:24:14.000000000 -0800
+++ b/services/mesh.c	2022-12-09 14:31:40.388406469 -0800
@@ -2003,3 +2003,10 @@
 		mesh_do_callback(mstate, LDNS_RCODE_NOERROR, msg->rep, c);
 	}
 }
+
+int mesh_jostle_exceeded(struct mesh_area* mesh)
+{
+	if(mesh->all.count < mesh->max_reply_states)
+		return 0;
+	return 1;
+}
diff --git a/services/mesh.h b/services/mesh.h
index 3be9b63fa..25121a67b 100644
--- a/services/mesh.h
+++ b/services/mesh.h
@@ -685,4 +685,15 @@ struct dns_msg*
 mesh_serve_expired_lookup(struct module_qstate* qstate,
 	struct query_info* lookup_qinfo);
 
+/**
+ * See if the mesh has space for more queries. You can allocate queries
+ * anyway, but this checks for the allocated space.
+ * @param mesh: mesh area.
+ * @return true if the query list is full.
+ * 	It checks the number of all queries, not just number of reply states,
+ * 	that have a client address. So that spawned queries count too,
+ * 	that were created by the iterator, or other modules.
+ */
+int mesh_jostle_exceeded(struct mesh_area* mesh);
+
 #endif /* SERVICES_MESH_H */
